
import { PDFDocument, PDFPage, PDFFont, rgb, StandardFonts, degrees, PageSizes, PDFImage } from 'pdf-lib';
import { ReportData, ReportOptions, SectionParams, Rotation, RotationTypes } from '../types';
import { StandardFonts as StandardFontsNames } from '@pdf-lib/standard-fonts';

// Import section generators
import { addHeaderSection } from '../sections/header';
import { addSummarySection } from '../sections/summary';
import { addBreakdownSection } from '../sections/breakdown';
import { addFooterSection } from '../sections/footer';
import { addExplanationSection } from '../sections/explanation';
import { addConditionAssessmentSection } from '../sections/conditionAssessment';
import { addComparablesSection } from '../sections/comparables';

/**
 * Generate a premium PDF report
 * @param data Report data
 * @param options Report options
 * @returns PDF document as a Uint8Array
 */
export async function generatePremiumReport(
  data: ReportData,
  options: Partial<ReportOptions> = {}
): Promise<Uint8Array> {
  // Create a new PDF document
  const pdfDoc = await PDFDocument.create();
  
  // Set default options
  const defaultOptions: ReportOptions = {
    watermarkText: 'Car Detective Premium Report',
    logoUrl: 'https://example.com/logo.png',
    showPremiumWatermark: true,
    includeExplanation: true,
    includeComparables: true,
    includeFooter: true,
    footerText: 'Generated by Car Detective © ' + new Date().getFullYear(),
    primaryColor: '#3B82F6',
    secondaryColor: '#0F172A',
    fonts: {
      titleFont: StandardFontsNames.HelveticaBold,
      bodyFont: StandardFontsNames.Helvetica,
    }
  };
  
  // Merge options
  const mergedOptions = { ...defaultOptions, ...options };
  
  // Add a page
  const page = pdfDoc.addPage(PageSizes.A4);
  
  // Get page dimensions
  const { width, height } = page.getSize();
  
  // Load fonts
  const regularFont = await pdfDoc.embedFont(StandardFonts.Helvetica);
  const boldFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
  
  // Define colors from options
  const primaryColor = rgb(
    parseInt(mergedOptions.primaryColor.substring(1, 3), 16) / 255,
    parseInt(mergedOptions.primaryColor.substring(3, 5), 16) / 255,
    parseInt(mergedOptions.primaryColor.substring(5, 7), 16) / 255
  );
  
  const secondaryColor = rgb(
    parseInt(mergedOptions.secondaryColor.substring(1, 3), 16) / 255,
    parseInt(mergedOptions.secondaryColor.substring(3, 5), 16) / 255,
    parseInt(mergedOptions.secondaryColor.substring(5, 7), 16) / 255
  );
  
  // Load logo if URL is provided
  let logo: PDFImage | undefined;
  if (mergedOptions.logoUrl) {
    try {
      const logoResponse = await fetch(mergedOptions.logoUrl);
      const logoData = await logoResponse.arrayBuffer();
      logo = await pdfDoc.embedPng(new Uint8Array(logoData));
    } catch (error) {
      console.error('Error loading logo:', error);
    }
  }
  
  // Draw premium watermark if enabled
  if (mergedOptions.showPremiumWatermark) {
    page.drawText('PREMIUM', {
      x: width / 2 - 120,
      y: height / 2,
      size: 100,
      font: boldFont,
      color: rgb(0.9, 0.9, 0.9),
      opacity: 0.1,
      rotate: {
        type: RotationTypes.Degrees,
        angle: 45
      } as Rotation,
    });
  }
  
  // Create section parameters
  const sectionParams: SectionParams = {
    pdfDoc,
    page,
    data,
    options: mergedOptions,
    fonts: {
      regular: regularFont,
      bold: boldFont,
    },
    fontSize: 12,
    startY: height - 50,
    margin: 50,
    width: width - 100,
    pageWidth: width,
    pageHeight: height,
    textColor: rgb(0.1, 0.1, 0.1),
    primaryColor
  };
  
  // Add sections to the PDF
  let currentY = await addHeaderSection({...sectionParams});
  currentY = currentY || height - 200; // Default if undefined
  
  // Add summary section
  if (currentY - 300 < 100) {
    // Not enough space, add a new page
    const newPage = pdfDoc.addPage(PageSizes.A4);
    sectionParams.page = newPage;
    sectionParams.startY = height - 50;
    currentY = height - 50;
  }
  
  currentY = await addSummarySection({...sectionParams, y: currentY});
  currentY = currentY || height - 350; // Default if undefined
  
  // Add breakdown section
  if (currentY - 400 < 100) {
    // Not enough space, add a new page
    const newPage = pdfDoc.addPage(PageSizes.A4);
    sectionParams.page = newPage;
    sectionParams.startY = height - 50;
    currentY = height - 50;
  }
  
  currentY = await addBreakdownSection({...sectionParams, y: currentY});
  currentY = currentY || height - 500; // Default if undefined
  
  // Add explanation section if enabled
  if (mergedOptions.includeExplanation && data.explanation) {
    if (currentY - 300 < 100) {
      // Not enough space, add a new page
      const newPage = pdfDoc.addPage(PageSizes.A4);
      sectionParams.page = newPage;
      sectionParams.startY = height - 50;
      currentY = height - 50;
    }
    
    currentY = await addExplanationSection({...sectionParams, y: currentY});
    currentY = currentY || height - 650; // Default if undefined
  }
  
  // Add condition assessment section if AI condition data is available
  if (data.aiCondition) {
    if (currentY - 300 < 100) {
      // Not enough space, add a new page
      const newPage = pdfDoc.addPage(PageSizes.A4);
      sectionParams.page = newPage;
      sectionParams.startY = height - 50;
      currentY = height - 50;
    }
    
    currentY = await addConditionAssessmentSection({...sectionParams, y: currentY});
    currentY = currentY || height - 800; // Default if undefined
  }
  
  // Add comparables section if enabled
  if (mergedOptions.includeComparables) {
    if (currentY - 400 < 100) {
      // Not enough space, add a new page
      const newPage = pdfDoc.addPage(PageSizes.A4);
      sectionParams.page = newPage;
      sectionParams.startY = height - 50;
      currentY = height - 50;
    }
    
    currentY = await addComparablesSection({...sectionParams, y: currentY});
    currentY = currentY || height - 950; // Default if undefined
  }
  
  // Add footer to all pages
  if (mergedOptions.includeFooter) {
    const pageCount = pdfDoc.getPageCount();
    for (let i = 0; i < pageCount; i++) {
      const page = pdfDoc.getPage(i);
      await addFooterSection({
        ...sectionParams,
        page,
        y: 30
      });
    }
  }
  
  // Serialize the PDFDocument to bytes
  return await pdfDoc.save();
}

/**
 * Add header section to the PDF
 */
async function addHeaderSection(params: SectionParams): Promise<number> {
  const { page, fonts, data, margin, width, pageWidth } = params;
  let { y = params.startY } = params;
  
  // Draw title
  page.drawText('Vehicle Valuation Report', {
    x: margin,
    y,
    size: 24,
    font: fonts.bold,
    color: params.textColor || rgb(0.1, 0.1, 0.1),
  });
  
  y -= 40;
  
  // Draw vehicle info
  page.drawText(`${data.year} ${data.make} ${data.model}`, {
    x: margin,
    y,
    size: 18,
    font: fonts.bold,
    color: params.primaryColor || rgb(0.2, 0.4, 0.8),
  });
  
  y -= 30;
  
  // Calculate base value from adjustments if not provided
  const baseValue = data.baseValue || 
    data.adjustments.reduce((total, adj) => total - adj.impact, data.estimatedValue);
  
  // Draw valuation
  page.drawText(`Estimated Value: $${data.estimatedValue.toLocaleString()}`, {
    x: margin,
    y,
    size: 14,
    font: fonts.bold,
    color: params.textColor || rgb(0.1, 0.1, 0.1),
  });
  
  y -= 25;
  
  // Draw confidence score
  const confidenceText = `Confidence Score: ${data.confidenceScore}%`;
  page.drawText(confidenceText, {
    x: margin,
    y,
    size: 12,
    font: fonts.regular,
    color: params.textColor || rgb(0.1, 0.1, 0.1),
  });
  
  y -= 25;
  
  // Draw date
  const date = new Date(data.generatedAt).toLocaleDateString();
  page.drawText(`Generated on: ${date}`, {
    x: margin,
    y,
    size: 10,
    font: fonts.regular,
    color: params.textColor || rgb(0.5, 0.5, 0.5),
  });
  
  y -= 20;
  
  // Draw horizontal line
  page.drawLine({
    start: { x: margin, y },
    end: { x: pageWidth - margin, y },
    thickness: 1,
    color: rgb(0.8, 0.8, 0.8),
  });
  
  return y - 20;
}

/**
 * Add vehicle summary section
 */
async function addSummarySection(params: SectionParams): Promise<number> {
  const { page, fonts, data, margin, width } = params;
  let { y = params.startY - 150 } = params;
  
  // Draw section title
  page.drawText('Vehicle Summary', {
    x: margin,
    y,
    size: 18,
    font: fonts.bold,
    color: params.textColor || rgb(0.1, 0.1, 0.1),
  });
  
  y -= 30;
  
  // Draw vehicle details in a grid format
  const details = [
    { label: 'Make:', value: data.make },
    { label: 'Model:', value: data.model },
    { label: 'Year:', value: data.year.toString() },
    { label: 'Mileage:', value: `${data.mileage.toLocaleString()} miles` },
    { label: 'Condition:', value: data.condition },
    { label: 'VIN:', value: data.vin || 'Not provided' },
    { label: 'Zip Code:', value: data.zipCode || 'Not provided' },
    { label: 'Transmission:', value: data.transmission || 'Not specified' },
    { label: 'Fuel Type:', value: data.fuelType || 'Not specified' },
    { label: 'Body Style:', value: data.bodyStyle || 'Not specified' },
  ];
  
  const colWidth = width / 2;
  const rowHeight = 25;
  
  for (let i = 0; i < details.length; i++) {
    const row = Math.floor(i / 2);
    const col = i % 2;
    const x = margin + col * colWidth;
    const yPos = y - row * rowHeight;
    
    // Draw label
    page.drawText(details[i].label, {
      x,
      y: yPos,
      size: 12,
      font: fonts.bold,
      color: params.textColor || rgb(0.3, 0.3, 0.3),
    });
    
    // Draw value
    page.drawText(details[i].value, {
      x: x + 100,
      y: yPos,
      size: 12,
      font: fonts.regular,
      color: params.textColor || rgb(0.1, 0.1, 0.1),
    });
  }
  
  return y - (Math.ceil(details.length / 2) * rowHeight) - 20;
}

/**
 * Add price breakdown section
 */
async function addBreakdownSection(params: SectionParams): Promise<number> {
  const { page, fonts, data, margin, width, pageWidth } = params;
  let { y = params.startY - 300 } = params;
  
  // Draw section title
  page.drawText('Price Breakdown', {
    x: margin,
    y,
    size: 18,
    font: fonts.bold,
    color: params.textColor || rgb(0.1, 0.1, 0.1),
  });
  
  y -= 30;
  
  // Calculate base value
  const baseValue = data.baseValue || 
    data.adjustments.reduce((total, adj) => total - adj.impact, data.estimatedValue);
  
  // Draw base value
  page.drawText(`Base Value:`, {
    x: margin,
    y,
    size: 14,
    font: fonts.bold,
    color: params.textColor || rgb(0.1, 0.1, 0.1),
  });
  
  const baseValueText = `$${baseValue.toLocaleString()}`;
  const baseValueWidth = fonts.bold.widthOfTextAtSize(baseValueText, 14);
  
  page.drawText(baseValueText, {
    x: pageWidth - margin - baseValueWidth,
    y,
    size: 14,
    font: fonts.bold,
    color: params.textColor || rgb(0.1, 0.1, 0.1),
  });
  
  y -= 25;
  
  // Draw horizontal line
  page.drawLine({
    start: { x: margin, y: y + 10 },
    end: { x: pageWidth - margin, y: y + 10 },
    thickness: 0.5,
    color: rgb(0.8, 0.8, 0.8),
  });
  
  // Draw adjustments
  for (const adjustment of data.adjustments) {
    y -= 20;
    
    // Draw adjustment factor
    page.drawText(adjustment.factor, {
      x: margin + 20,
      y,
      size: 12,
      font: fonts.regular,
      color: params.textColor || rgb(0.3, 0.3, 0.3),
    });
    
    // If description is available, draw it
    if (adjustment.description) {
      page.drawText(`(${adjustment.description})`, {
        x: margin + 150,
        y,
        size: 10,
        font: fonts.regular,
        color: rgb(0.5, 0.5, 0.5),
      });
    }
    
    // Format adjustment value
    const prefix = adjustment.impact >= 0 ? '+' : '';
    const adjustmentText = `${prefix}$${adjustment.impact.toLocaleString()}`;
    const adjustmentWidth = fonts.regular.widthOfTextAtSize(adjustmentText, 12);
    
    // Draw adjustment value
    page.drawText(adjustmentText, {
      x: pageWidth - margin - adjustmentWidth,
      y,
      size: 12,
      font: fonts.regular,
      color: adjustment.impact >= 0 ? rgb(0.2, 0.7, 0.2) : rgb(0.7, 0.2, 0.2),
    });
  }
  
  y -= 25;
  
  // Draw horizontal line
  page.drawLine({
    start: { x: margin, y: y + 10 },
    end: { x: pageWidth - margin, y: y + 10 },
    thickness: 0.5,
    color: rgb(0.8, 0.8, 0.8),
  });
  
  // Draw final value
  page.drawText(`Final Value:`, {
    x: margin,
    y,
    size: 14,
    font: fonts.bold,
    color: params.textColor || rgb(0.1, 0.1, 0.1),
  });
  
  const finalValueText = `$${data.estimatedValue.toLocaleString()}`;
  const finalValueWidth = fonts.bold.widthOfTextAtSize(finalValueText, 14);
  
  page.drawText(finalValueText, {
    x: pageWidth - margin - finalValueWidth,
    y,
    size: 14,
    font: fonts.bold,
    color: params.primaryColor || rgb(0.2, 0.4, 0.8),
  });
  
  return y - 30;
}

/**
 * Add explanation section to the PDF
 */
async function addExplanationSection(params: SectionParams): Promise<number> {
  const { page, fonts, data, margin, width } = params;
  let { y = params.startY - 450, height = 300 } = params;
  
  // Draw section title
  page.drawText('Market Analysis', {
    x: margin,
    y,
    size: 18,
    font: fonts.bold,
    color: params.textColor || rgb(0.1, 0.1, 0.1),
  });
  
  y -= 30;
  
  // If explanation is provided, draw it
  if (data.explanation) {
    const explanationLines = splitTextIntoLines(data.explanation, fonts.regular, 12, width);
    
    for (const line of explanationLines) {
      page.drawText(line, {
        x: margin,
        y,
        size: 12,
        font: fonts.regular,
        color: params.textColor || rgb(0.3, 0.3, 0.3),
      });
      
      y -= 20;
    }
  } else {
    // Draw placeholder text
    page.drawText('No market analysis available for this vehicle.', {
      x: margin,
      y,
      size: 12,
      font: fonts.regular,
      color: rgb(0.5, 0.5, 0.5),
    });
    
    y -= 20;
  }
  
  return y - 10;
}

/**
 * Add condition assessment section to the PDF
 */
async function addConditionAssessmentSection(params: SectionParams): Promise<number> {
  const { page, fonts, data, margin, width } = params;
  let { y = params.startY - 600, height = 300 } = params;
  
  // Draw section title
  page.drawText('Condition Assessment', {
    x: margin,
    y,
    size: 18,
    font: fonts.bold,
    color: params.textColor || rgb(0.1, 0.1, 0.1),
  });
  
  y -= 30;
  
  // If AI condition data is available, draw it
  if (data.aiCondition) {
    // Draw condition rating
    page.drawText(`Overall Condition: ${data.aiCondition.condition}`, {
      x: margin,
      y,
      size: 14,
      font: fonts.bold,
      color: params.primaryColor || rgb(0.2, 0.4, 0.8),
    });
    
    y -= 25;
    
    // Draw confidence score
    page.drawText(`Confidence: ${data.aiCondition.confidenceScore}%`, {
      x: margin,
      y,
      size: 12,
      font: fonts.regular,
      color: params.textColor || rgb(0.3, 0.3, 0.3),
    });
    
    y -= 25;
    
    // Draw summary
    if (data.aiCondition.summary) {
      const summaryLines = splitTextIntoLines(data.aiCondition.summary, fonts.regular, 12, width);
      
      for (const line of summaryLines) {
        page.drawText(line, {
          x: margin,
          y,
          size: 12,
          font: fonts.regular,
          color: params.textColor || rgb(0.3, 0.3, 0.3),
        });
        
        y -= 20;
      }
    }
    
    y -= 10;
    
    // Draw issues detected
    if (data.aiCondition.issuesDetected && data.aiCondition.issuesDetected.length > 0) {
      page.drawText('Issues Detected:', {
        x: margin,
        y,
        size: 12,
        font: fonts.bold,
        color: params.textColor || rgb(0.3, 0.3, 0.3),
      });
      
      y -= 20;
      
      for (const issue of data.aiCondition.issuesDetected) {
        page.drawText(`• ${issue}`, {
          x: margin + 10,
          y,
          size: 12,
          font: fonts.regular,
          color: params.textColor || rgb(0.3, 0.3, 0.3),
        });
        
        y -= 20;
      }
    }
  } else {
    // Draw placeholder text
    page.drawText('No condition assessment available for this vehicle.', {
      x: margin,
      y,
      size: 12,
      font: fonts.regular,
      color: rgb(0.5, 0.5, 0.5),
    });
    
    y -= 20;
  }
  
  return y - 10;
}

/**
 * Add comparables section to the PDF
 */
async function addComparablesSection(params: SectionParams): Promise<number> {
  const { page, fonts, data, margin, width } = params;
  let { y = params.startY - 750, height = 300 } = params;
  
  // Draw section title
  page.drawText('Comparable Vehicles', {
    x: margin,
    y,
    size: 18,
    font: fonts.bold,
    color: params.textColor || rgb(0.1, 0.1, 0.1),
  });
  
  y -= 30;
  
  // Generate placeholder comparable vehicles
  const comparables = [
    {
      year: data.year,
      make: data.make,
      model: data.model,
      mileage: data.mileage - 5000,
      price: data.estimatedValue + 1500,
      condition: 'Excellent',
      distance: '15 miles'
    },
    {
      year: data.year,
      make: data.make,
      model: data.model,
      mileage: data.mileage + 8000,
      price: data.estimatedValue - 2000,
      condition: 'Good',
      distance: '8 miles'
    },
    {
      year: data.year - 1,
      make: data.make,
      model: data.model,
      mileage: data.mileage - 10000,
      price: data.estimatedValue - 3000,
      condition: 'Good',
      distance: '22 miles'
    }
  ];
  
  // Draw table header
  const headers = ['Year', 'Make/Model', 'Mileage', 'Condition', 'Price', 'Distance'];
  const colWidths = [50, 150, 100, 80, 80, 80];
  const startX = margin;
  
  for (let i = 0; i < headers.length; i++) {
    const x = startX + colWidths.slice(0, i).reduce((total, w) => total + w, 0);
    
    page.drawText(headers[i], {
      x,
      y,
      size: 12,
      font: fonts.bold,
      color: params.textColor || rgb(0.1, 0.1, 0.1),
    });
  }
  
  y -= 20;
  
  // Draw horizontal line
  page.drawLine({
    start: { x: margin, y: y + 5 },
    end: { x: margin + colWidths.reduce((total, w) => total + w, 0), y: y + 5 },
    thickness: 0.5,
    color: rgb(0.8, 0.8, 0.8),
  });
  
  // Draw comparable vehicles
  for (const comparable of comparables) {
    y -= 25;
    
    // Draw row data
    const rowData = [
      comparable.year.toString(),
      `${comparable.make} ${comparable.model}`,
      `${comparable.mileage.toLocaleString()} mi`,
      comparable.condition,
      `$${comparable.price.toLocaleString()}`,
      comparable.distance
    ];
    
    for (let i = 0; i < rowData.length; i++) {
      const x = startX + colWidths.slice(0, i).reduce((total, w) => total + w, 0);
      
      page.drawText(rowData[i], {
        x,
        y,
        size: 12,
        font: fonts.regular,
        color: params.textColor || rgb(0.3, 0.3, 0.3),
      });
    }
  }
  
  y -= 40;
  
  // Draw note
  page.drawText('Note: Comparable vehicles are based on similar make, model, year, and condition in your area.', {
    x: margin,
    y,
    size: 10,
    font: fonts.regular,
    color: rgb(0.5, 0.5, 0.5),
  });
  
  return y - 10;
}

/**
 * Add footer section to the PDF
 */
async function addFooterSection(params: SectionParams): Promise<number> {
  const { page, fonts, options, margin, pageWidth } = params;
  let { y = 30 } = params;
  
  // Draw horizontal line
  page.drawLine({
    start: { x: margin, y: y + 15 },
    end: { x: pageWidth - margin, y: y + 15 },
    thickness: 0.5,
    color: rgb(0.8, 0.8, 0.8),
  });
  
  // Draw footer text
  const footerText = options.footerText || 'Generated by Car Detective';
  page.drawText(footerText, {
    x: margin,
    y,
    size: 8,
    font: fonts.regular,
    color: rgb(0.5, 0.5, 0.5),
  });
  
  // Draw page number
  const pageText = `Page ${page.getIndex() + 1} of ${params.pdfDoc.getPageCount()}`;
  const pageTextWidth = fonts.regular.widthOfTextAtSize(pageText, 8);
  
  page.drawText(pageText, {
    x: pageWidth - margin - pageTextWidth,
    y,
    size: 8,
    font: fonts.regular,
    color: rgb(0.5, 0.5, 0.5),
  });
  
  return y - 10;
}

/**
 * Split text into lines that fit within a given width
 */
function splitTextIntoLines(text: string, font: PDFFont, fontSize: number, maxWidth: number): string[] {
  const words = text.split(' ');
  const lines: string[] = [];
  let currentLine = '';
  
  for (const word of words) {
    const testLine = currentLine ? currentLine + ' ' + word : word;
    const width = font.widthOfTextAtSize(testLine, fontSize);
    
    if (width <= maxWidth) {
      currentLine = testLine;
    } else {
      lines.push(currentLine);
      currentLine = word;
    }
  }
  
  if (currentLine) {
    lines.push(currentLine);
  }
  
  return lines;
}
