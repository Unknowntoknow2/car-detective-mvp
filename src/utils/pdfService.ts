
import { Buffer } from 'buffer';
import { PDFDocument, rgb, StandardFonts, degrees } from 'pdf-lib';
import { supabase } from '@/integrations/supabase/client';
import { v4 as uuidv4 } from 'uuid';
import { MarketListing, getNormalizedUrl, getNormalizedSourceType, normalizeListing } from '@/types/marketListing';

// Types
export interface ReportData {
  id: string;
  make: string;
  model: string;
  year: number;
  mileage: number;
  condition: string;
  estimatedValue: number;
  price: number;
  confidenceScore: number;
  vin?: string;
  zipCode: string;
  adjustments: Array<{
    factor: string;
    impact: number;
    description: string;
  }>;
  generatedAt: string;
  priceRange: [number, number];
  isPremium: boolean;
  aiCondition?: {
    condition: string;
    confidenceScore: number;
    issuesDetected: string[];
    aiSummary: string;
  };
  basePrice?: number;
  competitorPrices?: number[];
  competitorAverage?: number;
  marketplaceListings?: MarketListing[];
  auctionResults?: any[];
}

export interface PdfOptions {
  includeWatermark?: boolean;
  includeTracking?: boolean;
  userId?: string;
}

// Helper function to convert vehicle info to report data
export function convertVehicleInfoToReportData(vehicleInfo: any, valuationData: any): ReportData {
  return {
    id: vehicleInfo.id || Date.now().toString(),
    make: vehicleInfo.make,
    model: vehicleInfo.model,
    year: vehicleInfo.year,
    mileage: valuationData.mileage,
    condition: valuationData.condition,
    estimatedValue: valuationData.estimatedValue,
    price: valuationData.estimatedValue,
    confidenceScore: valuationData.confidenceScore || 0,
    vin: vehicleInfo.vin,
    zipCode: valuationData.zipCode,
    adjustments: valuationData.adjustments || [],
    generatedAt: new Date().toISOString(),
    priceRange: valuationData.priceRange || [0, 0],
    isPremium: valuationData.isPremium || false
  };
}

// Generate tracking ID
function generateTrackingId(userId?: string, vin?: string): string {
  const timestamp = Date.now();
  const vinPart = vin ? vin.slice(-6) : 'NOVIN';
  const userPart = userId ? userId.slice(0, 8) : 'GUEST';
  const randomPart = uuidv4().slice(0, 8);
  
  return `CD-${userPart}-${vinPart}-${timestamp}-${randomPart}`.toUpperCase();
}

// Add watermark and tracking to PDF
async function addWatermarkAndTracking(
  pdfBytes: Uint8Array,
  trackingId: string,
  isPremium: boolean = false
): Promise<Uint8Array> {
  try {
    const pdfDoc = await PDFDocument.load(pdfBytes);
    const pages = pdfDoc.getPages();
    const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
    
    const watermarkText = isPremium 
      ? 'CarPerfector Premium Valuation ‚Äì For Dealer Use Only'
      : 'CarPerfector Valuation Report';
    
    for (const page of pages) {
      const { width, height } = page.getSize();
      
      // Add tracking footer
      page.drawText(`Generated by CarPerfector | Report ID: ${trackingId}`, {
        x: width - 300,
        y: 20,
        size: 8,
        font,
        color: rgb(0.6, 0.6, 0.6),
      });
      
      // Add watermark
      page.drawText(watermarkText, {
        x: width / 2 - 100,
        y: height / 2,
        size: 24,
        font,
        color: rgb(0.9, 0.9, 0.9),
        opacity: 0.1,
        rotate: degrees(45),
      });
    }
    
    return await pdfDoc.save();
  } catch (error) {
    console.error('Error adding watermark to PDF:', error);
    return pdfBytes;
  }
}

// Log PDF generation
async function logPdfGeneration(
  trackingId: string,
  vin: string,
  userId?: string
): Promise<void> {
  if (!userId) return;
  
  try {
    const { error } = await supabase
      .from('pdf_audit_logs')
      .insert({
        vin,
        tracking_id: trackingId,
        user_id: userId,
        created_at: new Date().toISOString()
      });
    
    if (error) {
      console.error('Failed to log PDF generation:', error);
    }
  } catch (error) {
    console.error('Error logging PDF generation:', error);
  }
}

// Core PDF generation function
export async function generateValuationPdf(data: ReportData, options: PdfOptions = {}): Promise<Buffer> {
  const pdfDoc = await PDFDocument.create();
  const page = pdfDoc.addPage([595, 842]); // A4 size

  const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
  const boldFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
  
  const { width, height } = page.getSize();
  const margin = 50;
  let yPosition = height - margin;

  // Title
  page.drawText('Vehicle Valuation Report', {
    x: margin,
    y: yPosition,
    size: 20,
    font: boldFont,
    color: rgb(0, 0, 0),
  });
  yPosition -= 40;

  // Vehicle Information
  const vehicleInfo = [
    ['VIN:', data.vin || 'N/A'],
    ['Year:', data.year?.toString() || 'N/A'],
    ['Make:', data.make || 'N/A'],
    ['Model:', data.model || 'N/A'],
    ['Mileage:', data.mileage?.toLocaleString() || 'N/A'],
    ['Condition:', data.condition || 'N/A'],
    ['ZIP Code:', data.zipCode || 'N/A'],
  ];

  vehicleInfo.forEach(([label, value]) => {
    page.drawText(label, {
      x: margin,
      y: yPosition,
      size: 12,
      font: boldFont,
      color: rgb(0.2, 0.2, 0.2),
    });
    
    page.drawText(value, {
      x: margin + 120,
      y: yPosition,
      size: 12,
      font: font,
      color: rgb(0, 0, 0),
    });
    
    yPosition -= 20;
  });

  // Valuation Results
  yPosition -= 20;
  page.drawText('Valuation Results', {
    x: margin,
    y: yPosition,
    size: 16,
    font: boldFont,
    color: rgb(0, 0, 0),
  });
  yPosition -= 30;

  page.drawText(`Estimated Value: $${data.estimatedValue?.toLocaleString() || '0'}`, {
    x: margin,
    y: yPosition,
    size: 14,
    font: boldFont,
    color: rgb(0, 0.5, 0),
  });
  yPosition -= 25;

  // Add MSRP information if available
  if (data.basePrice && data.basePrice > 0) {
    page.drawText(`MSRP Used: $${data.basePrice.toLocaleString()}`, {
      x: margin,
      y: yPosition,
      size: 10,
      font: font,
      color: rgb(0.4, 0.4, 0.4),
    });
    yPosition -= 15;
    
    page.drawText('Source: CarPerfector MSRP Database (Real vehicle data)', {
      x: margin,
      y: yPosition,
      size: 10,
      font: font,
      color: rgb(0.4, 0.4, 0.4),
    });
    yPosition -= 20;
  }

  if (data.priceRange && Array.isArray(data.priceRange)) {
    page.drawText(`Price Range: $${data.priceRange[0]?.toLocaleString()} - $${data.priceRange[1]?.toLocaleString()}`, {
      x: margin,
      y: yPosition,
      size: 12,
      font: font,
      color: rgb(0, 0, 0),
    });
    yPosition -= 20;
  }

  page.drawText(`Confidence Score: ${data.confidenceScore || 0}%`, {
    x: margin,
    y: yPosition,
    size: 12,
    font: font,
    color: rgb(0, 0, 0),
  });
  yPosition -= 30;

  // Value Breakdown Section
  if (data.adjustments && data.adjustments.length > 0) {
    page.drawText('Valuation Breakdown', {
      x: margin,
      y: yPosition,
      size: 16,
      font: boldFont,
      color: rgb(0, 0, 0),
    });
    yPosition -= 25;

    if (data.basePrice && data.basePrice > 0) {
      page.drawText(`Base MSRP: $${data.basePrice.toLocaleString()}`, {
        x: margin,
        y: yPosition,
        size: 11,
        font: font,
        color: rgb(0, 0, 0),
      });
      yPosition -= 18;
    }

    data.adjustments.forEach((adjustment) => {
      const adjustmentText = `${adjustment.factor}: ${adjustment.impact > 0 ? '+' : ''}$${adjustment.impact.toLocaleString()}`;
      page.drawText(adjustmentText, {
        x: margin,
        y: yPosition,
        size: 10,
        font: font,
        color: adjustment.impact > 0 ? rgb(0, 0.6, 0) : rgb(0.8, 0, 0),
      });
      
      // Add description on next line if available
      if (adjustment.description) {
        yPosition -= 12;
        page.drawText(`  ${adjustment.description}`, {
          x: margin,
          y: yPosition,
          size: 9,
          font: font,
          color: rgb(0.5, 0.5, 0.5),
        });
      }
      
      yPosition -= 16;
    });
  }

  // Add Market Listing Intelligence if available
  if (data.marketplaceListings && data.marketplaceListings.length > 0) {
    yPosition -= 20;
    page.drawText('üè∑Ô∏è Market Listing Intelligence', {
      x: margin,
      y: yPosition,
      size: 16,
      font: boldFont,
      color: rgb(0, 0, 0),
    });
    yPosition -= 25;

    // Normalize all listings for consistent field access
    const normalizedListings = data.marketplaceListings.map(normalizeListing);
    const avgPrice = Math.round(normalizedListings.reduce((sum, listing) => sum + (listing.price || 0), 0) / normalizedListings.length);
    
    page.drawText(`‚Ä¢ Real listings found: ${normalizedListings.length}`, {
      x: margin,
      y: yPosition,
      size: 11,
      font: font,
      color: rgb(0, 0, 0),
    });
    yPosition -= 15;

    page.drawText(`‚Ä¢ Average market price: $${avgPrice.toLocaleString()}`, {
      x: margin,
      y: yPosition,
      size: 11,
      font: font,
      color: rgb(0, 0, 0),
    });
    yPosition -= 15;

    // Show top 3 normalized listings with enhanced field access
    const topListings = normalizedListings.slice(0, 3);
    topListings.forEach((listing) => {
      const dealerName = listing.dealerName || listing.dealer_name || listing.dealer || 'Private Seller';
      const url = getNormalizedUrl(listing);
      const sourceType = getNormalizedSourceType(listing);
      
      const listingText = `- ${dealerName} ‚Äî $${(listing.price || 0).toLocaleString()} [${sourceType}]`.substring(0, 60);
      page.drawText(listingText, {
        x: margin,
        y: yPosition,
        size: 9,
        font: font,
        color: rgb(0.3, 0.3, 0.3),
      });
      yPosition -= 12;
    });

    page.drawText('‚Ä¢ Data verified via Enhanced Market Search', {
      x: margin,
      y: yPosition,
      size: 9,
      font: font,
      color: rgb(0.5, 0.5, 0.5),
    });
    yPosition -= 20;
  }

  // Add AI Condition if available
  if (data.aiCondition) {
    yPosition -= 20;
    page.drawText('AI Condition Assessment', {
      x: margin,
      y: yPosition,
      size: 16,
      font: boldFont,
      color: rgb(0, 0, 0),
    });
    yPosition -= 25;

    page.drawText(`AI Condition: ${data.aiCondition.condition}`, {
      x: margin,
      y: yPosition,
      size: 12,
      font: font,
      color: rgb(0, 0, 0),
    });
    yPosition -= 20;

    page.drawText(`AI Summary: ${data.aiCondition.aiSummary}`, {
      x: margin,
      y: yPosition,
      size: 10,
      font: font,
      color: rgb(0.3, 0.3, 0.3),
    });
  }

  // Add Market Listing Fallback Note if no listings were retrieved
  if (!data.marketplaceListings || (Array.isArray(data.marketplaceListings) && data.marketplaceListings.length === 0)) {
    yPosition -= 10;
    page.drawText('‚ÑπÔ∏è Market Listing Note', {
      x: margin,
      y: yPosition,
      size: 14,
      font: boldFont,
      color: rgb(0.2, 0.4, 0.8),
    });
    yPosition -= 20;

    const fallbackText = 'Live vehicle listings could not be retrieved at the time of your valuation.';
    page.drawText(fallbackText, {
      x: margin,
      y: yPosition,
      size: 10,
      font: font,
      color: rgb(0.4, 0.4, 0.4),
    });
    yPosition -= 15;

    const msrpText = 'This report uses MSRP estimates and vehicle-specific condition instead.';
    page.drawText(msrpText, {
      x: margin,
      y: yPosition,
      size: 10,
      font: font,
      color: rgb(0.4, 0.4, 0.4),
    });
    yPosition -= 20;
  }

  // Add footer with data source information
  const footerY = 60;
  page.drawText('Data Sources: CarPerfector MSRP Database, Market Analysis, Condition Assessment', {
    x: margin,
    y: footerY,
    size: 8,
    font: font,
    color: rgb(0.6, 0.6, 0.6),
  });

  let pdfBytes = await pdfDoc.save();

  // Add watermark and tracking if requested
  if (options.includeWatermark || options.includeTracking) {
    const trackingId = generateTrackingId(options.userId, data.vin);
    pdfBytes = await addWatermarkAndTracking(pdfBytes, trackingId, data.isPremium);
    
    if (options.includeTracking && data.vin && options.userId) {
      await logPdfGeneration(trackingId, data.vin, options.userId);
    }
  }

  return Buffer.from(pdfBytes);
}

// Download PDF function
export async function downloadValuationPdf(data: ReportData, options: PdfOptions = {}): Promise<void> {
  const pdfBuffer = await generateValuationPdf(data, options);
  
  const blob = new Blob([pdfBuffer as any], { type: 'application/pdf' });
  const url = URL.createObjectURL(blob);
  
  const link = document.createElement('a');
  link.href = url;
  link.download = `valuation-${data.make}-${data.model}-${data.year}.pdf`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  
  URL.revokeObjectURL(url);
}

// Upload PDF to Supabase Storage
export async function uploadValuationPdf(
  data: ReportData,
  options: PdfOptions = {}
): Promise<string | null> {
  try {
    const pdfBuffer = await generateValuationPdf(data, options);

    const fileName = `valuation-${data.id}.pdf`;
    const filePath = `pdfs/${fileName}`;

    const { error: uploadError } = await supabase.storage
      .from('valuation-pdfs')
      .upload(filePath, pdfBuffer, {
        contentType: 'application/pdf',
        upsert: true,
      });

    if (uploadError) {
      console.error('Error uploading PDF to Supabase:', uploadError);
      return null;
    }

    const { data: publicUrlData } = supabase.storage
      .from('valuation-pdfs')
      .getPublicUrl(filePath);

    if (!publicUrlData?.publicUrl) {
      console.error('Error getting public URL for PDF');
      return null;
    }

    return publicUrlData.publicUrl;
  } catch (error) {
    console.error('Error uploading PDF:', error);
    return null;
  }
}

// Legacy aliases for backward compatibility
export const downloadPdf = downloadValuationPdf;
export const generateReport = generateValuationPdf;
