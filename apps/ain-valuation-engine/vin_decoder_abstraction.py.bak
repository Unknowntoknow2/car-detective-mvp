import requests
import time
import logging
from abc import ABC, abstractmethod
from typing import Dict, Any, Optional, List
import os

logging.basicConfig(level=logging.INFO)

def fetch_nhtsa_recalls(vin: str) -> List[Dict[str, Any]]:
    """
    Fetch recall data for a VIN from the free NHTSA API.
    Returns a list of recall records (open and closed).
    """
    url = f"https://api.nhtsa.gov/recalls/recallsByVin/{vin}"
    try:
        resp = requests.get(url, timeout=10)
        resp.raise_for_status()
        data = resp.json()
        return data.get("results", [])
    except Exception as e:
        logging.error(f"NHTSA Recall API error: {e}")
        return []

# --- VIN Decoder Abstraction Layer ---

class VinDecodeProvider(ABC):
    """Abstract base class for VIN decode providers."""
    @abstractmethod
    def decode(self, vin: str) -> Dict[str, Any]:
        pass

    @abstractmethod
    def provider_name(self) -> str:
        pass

class NHTSAProvider(VinDecodeProvider):
    def decode(self, vin: str) -> Dict[str, Any]:
        url = f"https://vpic.nhtsa.dot.gov/api/vehicles/DecodeVin/{vin}?format=json"
        try:
            resp = requests.get(url, timeout=10)
            resp.raise_for_status()
            data = resp.json()
            result = {item['Variable']: item['Value'] for item in data['Results']}
            # Check for error codes or error text in the results
            error_code = None
            error_text = None
            for item in data['Results']:
                if item.get('Variable') == 'Error Code' and item.get('Value'):
                    error_code = item.get('Value')
                if item.get('Variable') == 'Error Text' and item.get('Value'):
                    error_text = item.get('Value')
            # Require Make, Model, and Model Year for a successful decode
            if not (result.get('Make') and result.get('Model') and result.get('Model Year')):
                result['error'] = "Incomplete decode: missing Make/Model/Year"
            elif error_code or error_text:
                # Only set error if error_code is not zero or error_text is meaningful
                if error_code not in (None, "0", 0) or (error_text and "clean" not in error_text.lower()):
                    result['error'] = f"{error_code or ''} {error_text or ''}".strip()
            return result
        except Exception as e:
            logging.error(f"NHTSA API error: {e}")
            return {"error": "NHTSA API error."}

    def provider_name(self) -> str:
        return "NHTSA"

class VinAuditProvider(VinDecodeProvider):
    """
    Commercial VIN decode provider for VinAudit API.
    Reads API key and endpoint from environment variables or .env file.
    Handles timeouts, rate limits, and provider-specific errors.
    """
    def __init__(self):
        self.api_key = os.getenv("VINAUDIT_API_KEY")
        self.endpoint = os.getenv("VINAUDIT_API_ENDPOINT", "https://api.vinaudit.com/v2/vehicle")
        self.timeout = int(os.getenv("VINAUDIT_API_TIMEOUT", "10"))
        self.max_retries = int(os.getenv("VINAUDIT_API_MAX_RETRIES", "2"))

    def decode(self, vin: str) -> Dict[str, Any]:
        if not self.api_key:
            return {"error": "VinAudit API key not set in environment."}
        params = {
            "vin": vin,
            "key": self.api_key,
            "format": "json"
        }
        attempt = 0
        while attempt <= self.max_retries:
            try:
                resp = requests.get(self.endpoint, params=params, timeout=self.timeout)
                resp.raise_for_status()
                data = resp.json()
                if data.get("error"):
                    # VinAudit returns error in response body
                    return {"error": data["error"]}
                # Map VinAudit fields to canonical schema as needed
                result = self._map_vinaudit_to_canonical(data)
                return result
            except requests.exceptions.Timeout:
                attempt += 1
                logging.warning(f"VinAudit timeout (attempt {attempt}/{self.max_retries})")
                if attempt > self.max_retries:
                    return {"error": "VinAudit API timeout."}
            except requests.exceptions.RequestException as e:
                logging.error(f"VinAudit API error: {e}")
                return {"error": f"VinAudit API error: {e}"}
        return {"error": "VinAudit provider failed after retries."}

    def _map_vinaudit_to_canonical(self, data: dict) -> dict:
        # Example mapping; update as needed for your schema
        mapping = {
            "vin": "VIN",
            "make": "Make",
            "model": "Model",
            "year": "Model Year",
            "trim": "Trim",
            "engine": "Engine Model",
            "engine_displacement": "Engine Displacement (L)",
            "fuel_type": "Fuel Type Primary",
            "body_type": "Body Class",
            "doors": "Doors",
            "plant_country": "Plant Country",
            "plant_state": "Plant State",
            "plant_city": "Plant City",
        }
        canonical = {v: data.get(k) for k, v in mapping.items()}
        return canonical

    def provider_name(self) -> str:
        return "VinAudit"

class CommercialProvider(VinDecodeProvider):
    def decode(self, vin: str) -> Dict[str, Any]:
        return {"error": "Commercial provider not implemented."}
    def provider_name(self) -> str:
        return "Commercial"

class VinDecoder:
    """
    VIN Decoder abstraction supporting multiple providers, error handling, compliance logging,
    and enrichment hooks (recall, geo, fuel, explainability).
    """
    def __init__(self, providers: List[VinDecodeProvider], rate_limit_per_minute: int = 60):
        self.providers = providers
        self.rate_limit_per_minute = rate_limit_per_minute
        self.last_call_time = 0

    def decode(self, vin: str) -> Dict[str, Any]:
        provenance = []
        compliance_log = []
        for provider in self.providers:
            # Rate limiting (simple per-call delay)
            now = time.time()
            if now - self.last_call_time < 60.0 / self.rate_limit_per_minute:
                time.sleep(60.0 / self.rate_limit_per_minute - (now - self.last_call_time))
            self.last_call_time = time.time()
            result = provider.decode(vin)
            compliance_event = {
                "provider": provider.provider_name(),
                "timestamp": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
                "vin": vin,
                "success": not result.get("error"),
                "error": result.get("error", None),
                "compliance_check": True,
            }
            compliance_log.append(compliance_event)
            provenance.append({
                "provider": provider.provider_name(),
                "timestamp": compliance_event["timestamp"],
                "success": compliance_event["success"],
                "error": compliance_event["error"]
            })
            if result and not result.get("error"):
                result['provider'] = provider.provider_name()
                result['provenance'] = provenance
                result['compliance_log'] = compliance_log
                result['recalls'] = fetch_nhtsa_recalls(vin)
                # Real enrichment (geo, fuel, market, etc.)
                from vehicle_data_enrichment import enrich_with_geocoding, enrich_with_epa_nhtsa, enrich_with_market_signals
                enriched = enrich_with_geocoding(result)
                enriched = enrich_with_epa_nhtsa(enriched)
                enriched = enrich_with_market_signals(enriched)
                # Attach compliance/provenance logs for enrichment
                if 'compliance_log' not in enriched:
                    enriched['compliance_log'] = []
                enriched['compliance_log'].extend([
                    {"step": "geo_enrichment", "status": enriched.get("geo_compliance", "n/a")},
                    {"step": "epa_nhtsa_enrichment", "status": enriched.get("epa_nhtsa_compliance", "n/a")},
                    {"step": "market_enrichment", "status": enriched.get("market_compliance", "n/a")},
                ])
                result = enriched
                result['explainability'] = explainability_stub(result)
                return result
        return {"error": "All providers failed.", "provenance": provenance, "compliance_log": compliance_log}

def explainability_stub(decoded: dict) -> dict:
    return {
        "confidence": 0.99 if decoded.get("Make") else 0.0,
        "provider": decoded.get("provider"),
        "rationale": "Decoded using provider and mapped to canonical schema."
    }

CANONICAL_FIELD_MAP = {
    'Make': 'make',
    'Model': 'model',
    'Model Year': 'year',
    'Trim': 'trim',
    'Engine Configuration': 'engine_config',
    'Engine Displacement (L)': 'engine_displacement_l',
    'Drive Type': 'drivetrain',
    'Body Class': 'body',
    'Transmission Style': 'transmission',
    'Fuel Type Primary': 'fuel',
    'Plant Country': 'plant_country',
    'Plant State': 'plant_state',
    'Plant City': 'plant_city',
    'Doors': 'doors',
    'Seats': 'seats',
    'Seat Rows': 'seat_rows',
    'Series': 'series',
    'Air Bag Locations': 'airbags',
    'Seat Belt Type': 'seat_belt',
    'Other Restraint Info': 'restraint',
}

def data_quality_score(decoded_vehicle: dict, required_fields=None):
    if required_fields is None:
        required_fields = list(CANONICAL_FIELD_MAP.keys())
    filled = sum(1 for f in required_fields if decoded_vehicle.get(f) not in [None, '', 'NA', 'N/A'])
    return round(100 * filled / len(required_fields))

CANONICAL_FIELDS = [
    "VIN", "Make", "Model", "Model Year", "Manufacturer Name", "Plant Country", "Plant State", "Plant City", "Plant Company Name", "Vehicle Type", "Series", "Trim",
    "Drive Type", "Transmission Style", "Transmission Speeds", "Doors", "Seats", "Seat Rows", "Body Class",
    "Engine Displacement (L)", "Engine Configuration", "Engine Cylinders", "Engine Model", "Valve Train Design", "Engine Stroke Cycles", "Engine Manufacturer", "Fuel Type Primary",
    "Air Bag Locations", "Seat Belt Type", "Other Restraint Info", "Pretensioner"
]

NHTSA_TO_CANONICAL = {
    "VIN": "VIN",
    "Make": "Make",
    "Model": "Model",
    "Model Year": "Model Year",
    "Manufacturer Name": "Manufacturer Name",
    "Plant Country": "Plant Country",
    "Plant State": "Plant State",
    "Plant City": "Plant City",
    "Plant Company Name": "Plant Company Name",
    "Vehicle Type": "Vehicle Type",
    "Series": "Series",
    "Trim": "Trim",
    "Drive Type": "Drive Type",
    "Transmission Style": "Transmission Style",
    "Transmission Speeds": "Transmission Speeds",
    "Doors": "Doors",
    "Number of Doors": "Doors",
    "Seats": "Seats",
    "Number of Seats": "Seats",
    "Seat Rows": "Seat Rows",
    "Number of Seat Rows": "Seat Rows",
    "Body Class": "Body Class",
    "Engine Displacement (L)": "Engine Displacement (L)",
    "Displacement (L)": "Engine Displacement (L)",
    "Engine Configuration": "Engine Configuration",
    "Engine Cylinders": "Engine Cylinders",
    "Cylinders": "Engine Cylinders",
    "Engine Model": "Engine Model",
    "Valve Train Design": "Valve Train Design",
    "Engine Stroke Cycles": "Engine Stroke Cycles",
    "Engine Manufacturer": "Engine Manufacturer",
    "Fuel Type - Primary": "Fuel Type Primary",
    "Fuel Type Primary": "Fuel Type Primary",
    "Air Bag Locations": "Air Bag Locations",
    "Front Air Bag Locations": "Air Bag Locations",
    "Seat Belt Type": "Seat Belt Type",
    "Other Restraint System Info": "Other Restraint Info",
    "Pretensioner": "Pretensioner"
}

def map_to_canonical(raw: Dict[str, Any], vin: str = None) -> Dict[str, Any]:
    """
    Map raw provider output to canonical schema, including provenance and explainability fields.
    """
    canonical = {field: None for field in CANONICAL_FIELDS}
    if vin:
        canonical["VIN"] = vin
    for k, v in raw.items():
        if k in NHTSA_TO_CANONICAL and v not in (None, "", "Not Applicable", "0"):
            canonical[NHTSA_TO_CANONICAL[k]] = v
    # Attach enrichment and compliance fields if present
    for extra in ["provenance", "compliance_log", "recalls", "geo", "fuel", "explainability"]:
        if extra in raw:
            canonical[extra] = raw[extra]
    return canonical

def decode_and_map(vin: str) -> Dict[str, Any]:
    """
    Decode a VIN using all available providers, map to canonical schema, and enrich with recall/provenance.
    """
    decoder = VinDecoder([NHTSAProvider(), VinAuditProvider(), CommercialProvider()])
    raw = decoder.decode(vin)
    if 'error' in raw:
        logging.error(f"VIN decode failed: {raw['error']}. Please check the VIN or try a different provider.")
        return {"error": raw["error"], "provenance": raw.get("provenance", [])}
    canonical = map_to_canonical(raw, vin=vin)
    # If all canonical fields except VIN, provenance, recalls, compliance_log, geo, fuel, explainability are None/empty, treat as error
    non_empty = [v for k, v in canonical.items() if k not in ('VIN','provenance','recalls','compliance_log','geo','fuel','explainability') and v not in (None, '', 'NA', 'N/A')]
    if not non_empty:
        error_result = {"error": "VIN decode failed: No valid data returned.", "provenance": raw.get('provenance', [])}
        logging.error(error_result["error"])
        return error_result
    missing = [f for f in CANONICAL_FIELD_MAP if canonical.get(f) in (None, '', 'NA', 'N/A')]
    if missing:
        logging.info(f"The following fields are missing or incomplete: {', '.join(missing)}. You may supplement these manually or with another provider.")
    return canonical

if __name__ == "__main__":
    import sys
    import json
    if len(sys.argv) > 2 and sys.argv[1] == "recalls":
        vin = sys.argv[2]
        recalls = fetch_nhtsa_recalls(vin)
        print(json.dumps(recalls, indent=2))
    else:
        test_vin = sys.argv[1] if len(sys.argv) > 1 else "4T1C11AK3PU162087"
        result = decode_and_map(test_vin)
        print(json.dumps(result, indent=2))
        print(f"Data quality score: {data_quality_score(result)}%")
