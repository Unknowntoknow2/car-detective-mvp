-- =====================================================================
-- AIN Phase 1â€“2 Enhancement Migration
-- Adds VIN validation, security, and caching to existing schema
-- Created: 2025-08-08
-- =====================================================================

-- Extensions
CREATE EXTENSION IF NOT EXISTS pgcrypto;  -- for gen_random_uuid()

-- =========================
-- VIN Validation Utilities
-- =========================

-- Regex excludes I,O,Q and enforces 17 chars
CREATE OR REPLACE FUNCTION fn_validate_vin_format(vin TEXT)
RETURNS BOOLEAN LANGUAGE SQL IMMUTABLE AS $$
  SELECT vin ~ '^[A-HJ-NPR-Z0-9]{17}$';
$$;

-- Transliteration for check digit
CREATE OR REPLACE FUNCTION fn_vin_char_value(c CHAR)
RETURNS INT LANGUAGE SQL IMMUTABLE AS $$
  SELECT CASE UPPER(c)
    WHEN 'A' THEN 1 WHEN 'B' THEN 2 WHEN 'C' THEN 3 WHEN 'D' THEN 4 WHEN 'E' THEN 5
    WHEN 'F' THEN 6 WHEN 'G' THEN 7 WHEN 'H' THEN 8
    WHEN 'J' THEN 1 WHEN 'K' THEN 2 WHEN 'L' THEN 3 WHEN 'M' THEN 4 WHEN 'N' THEN 5
    WHEN 'P' THEN 7 WHEN 'R' THEN 9
    WHEN 'S' THEN 2 WHEN 'T' THEN 3 WHEN 'U' THEN 4 WHEN 'V' THEN 5 WHEN 'W' THEN 6
    WHEN 'X' THEN 7 WHEN 'Y' THEN 8 WHEN 'Z' THEN 9
    WHEN '0' THEN 0 WHEN '1' THEN 1 WHEN '2' THEN 2 WHEN '3' THEN 3 WHEN '4' THEN 4
    WHEN '5' THEN 5 WHEN '6' THEN 6 WHEN '7' THEN 7 WHEN '8' THEN 8 WHEN '9' THEN 9
  END;
$$;

-- Weights by position 1..17, skipping 9th (check digit)
CREATE OR REPLACE FUNCTION fn_vin_weight(pos INT)
RETURNS INT LANGUAGE SQL IMMUTABLE AS $$
  SELECT CASE pos
    WHEN 1 THEN 8 WHEN 2 THEN 7 WHEN 3 THEN 6 WHEN 4 THEN 5 WHEN 5 THEN 4
    WHEN 6 THEN 3 WHEN 7 THEN 2 WHEN 8 THEN 10
    WHEN 9 THEN 0
    WHEN 10 THEN 9 WHEN 11 THEN 8 WHEN 12 THEN 7 WHEN 13 THEN 6
    WHEN 14 THEN 5 WHEN 15 THEN 4 WHEN 16 THEN 3 WHEN 17 THEN 2
  END;
$$;

CREATE OR REPLACE FUNCTION fn_vin_expected_check_digit(vin TEXT)
RETURNS TEXT LANGUAGE PLPGSQL IMMUTABLE AS $$
DECLARE 
  sum INT := 0; 
  ch CHAR; 
  val INT; 
  w INT; 
  r INT;
BEGIN
  IF NOT fn_validate_vin_format(vin) THEN RETURN NULL; END IF;
  
  FOR i IN 1..17 LOOP
    ch := SUBSTRING(vin FROM i FOR 1);
    val := fn_vin_char_value(ch);
    w := fn_vin_weight(i);
    sum := sum + (val * w);
  END LOOP;
  
  r := sum % 11;
  RETURN CASE r WHEN 10 THEN 'X' ELSE r::TEXT END;
END;
$$;

-- Master VIN validation (format + checksum)
CREATE OR REPLACE FUNCTION fn_validate_vin(vin TEXT)
RETURNS BOOLEAN LANGUAGE PLPGSQL IMMUTABLE AS $$
DECLARE
  check_digit CHAR;
  expected_digit TEXT;
BEGIN
  IF NOT fn_validate_vin_format(vin) THEN RETURN FALSE; END IF;
  
  check_digit := SUBSTRING(vin FROM 9 FOR 1);
  expected_digit := fn_vin_expected_check_digit(vin);
  
  RETURN check_digit = expected_digit;
END;
$$;

-- =====================================================
-- 2. ENHANCE EXISTING TABLES
-- =====================================================

-- Add VIN validation columns to existing vehicle_specs table
DO $$ 
BEGIN
    -- Add vin_checksum if it doesn't exist
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                  WHERE table_name = 'vehicle_specs' AND column_name = 'vin_checksum') THEN
        ALTER TABLE vehicle_specs ADD COLUMN vin_checksum CHAR(1);
        COMMENT ON COLUMN vehicle_specs.vin_checksum IS 'ISO 3779 VIN check digit';
    END IF;
    
    -- Add validation_status if it doesn't exist
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                  WHERE table_name = 'vehicle_specs' AND column_name = 'validation_status') THEN
        ALTER TABLE vehicle_specs ADD COLUMN validation_status VARCHAR(20) DEFAULT 'valid';
        COMMENT ON COLUMN vehicle_specs.validation_status IS 'VIN validation result: valid, invalid, unchecked';
    END IF;
    
    -- Add data_source if it doesn't exist
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                  WHERE table_name = 'vehicle_specs' AND column_name = 'data_source') THEN
        ALTER TABLE vehicle_specs ADD COLUMN data_source VARCHAR(50) DEFAULT 'nhtsa';
        COMMENT ON COLUMN vehicle_specs.data_source IS 'Source of vehicle data: nhtsa, user_input, api_cache';
    END IF;
END $$;

-- Add VIN validation constraint
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.check_constraints 
        WHERE constraint_name = 'vehicle_specs_vin_format_check'
    ) THEN
        ALTER TABLE vehicle_specs ADD CONSTRAINT vehicle_specs_vin_format_check 
        CHECK (fn_validate_vin_format(vin));
    END IF;
END $$;

-- =====================================================
-- 3. API CACHE TABLE
-- =====================================================
CREATE TABLE IF NOT EXISTS api_cache (
    id BIGSERIAL PRIMARY KEY,
    cache_key VARCHAR(255) UNIQUE NOT NULL,
    endpoint VARCHAR(100) NOT NULL,
    request_params JSONB,
    response_data JSONB NOT NULL,
    status_code INTEGER DEFAULT 200,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ DEFAULT (NOW() + INTERVAL '24 hours'),
    hit_count INTEGER DEFAULT 0
);

-- Indexes for api_cache
CREATE INDEX IF NOT EXISTS idx_api_cache_key ON api_cache(cache_key);
CREATE INDEX IF NOT EXISTS idx_api_cache_endpoint ON api_cache(endpoint);
CREATE INDEX IF NOT EXISTS idx_api_cache_expires_at ON api_cache(expires_at);
CREATE INDEX IF NOT EXISTS idx_api_cache_created_at ON api_cache(created_at);

-- =====================================================
-- 4. RLS POLICIES
-- =====================================================

-- Enable RLS on all tables
ALTER TABLE vehicle_specs ENABLE ROW LEVEL SECURITY;
ALTER TABLE nhtsa_recalls ENABLE ROW LEVEL SECURITY;
ALTER TABLE nhtsa_safety_ratings ENABLE ROW LEVEL SECURITY;
ALTER TABLE fuel_economy ENABLE ROW LEVEL SECURITY;
ALTER TABLE api_cache ENABLE ROW LEVEL SECURITY;

-- Public read access for vehicle_specs
CREATE POLICY IF NOT EXISTS "vehicle_specs_public_read" ON vehicle_specs
    FOR SELECT USING (true);

-- Public read access for nhtsa_recalls
CREATE POLICY IF NOT EXISTS "nhtsa_recalls_public_read" ON nhtsa_recalls
    FOR SELECT USING (true);

-- Public read access for nhtsa_safety_ratings
CREATE POLICY IF NOT EXISTS "nhtsa_safety_ratings_public_read" ON nhtsa_safety_ratings
    FOR SELECT USING (true);

-- Public read access for fuel_economy
CREATE POLICY IF NOT EXISTS "fuel_economy_public_read" ON fuel_economy
    FOR SELECT USING (true);

-- Service role access for api_cache
CREATE POLICY IF NOT EXISTS "api_cache_service_access" ON api_cache
    FOR ALL USING (auth.role() = 'service_role');

-- =====================================================
-- 5. RPC FUNCTIONS
-- =====================================================

-- Upsert vehicle specs with validation
CREATE OR REPLACE FUNCTION rpc_upsert_vehicle_specs(
    p_vin TEXT,
    p_make TEXT,
    p_model TEXT,
    p_year INTEGER,
    p_specs JSONB DEFAULT '{}'::JSONB
)
RETURNS TABLE(vin TEXT, validation_status TEXT, created BOOLEAN)
LANGUAGE PLPGSQL
SECURITY DEFINER
AS $$
DECLARE
    v_checksum CHAR(1);
    v_is_valid BOOLEAN;
    v_exists BOOLEAN;
    result_created BOOLEAN;
BEGIN
    -- Validate VIN format and checksum
    IF NOT fn_validate_vin_format(p_vin) THEN
        RETURN QUERY SELECT p_vin, 'invalid_format'::TEXT, FALSE;
        RETURN;
    END IF;
    
    v_checksum := SUBSTRING(p_vin FROM 9 FOR 1);
    v_is_valid := fn_validate_vin(p_vin);
    
    -- Check if record exists
    SELECT EXISTS(SELECT 1 FROM vehicle_specs WHERE vehicle_specs.vin = p_vin) INTO v_exists;
    result_created := NOT v_exists;
    
    -- Upsert with validation data
    INSERT INTO vehicle_specs (
        vin, make, model, year, vin_checksum, validation_status,
        trim, body_class, engine_cylinders, displacement_cc, fuel_type_primary,
        drive_type, transmission_style, manufacturer, plant_country, plant_state,
        vehicle_type, gvwr, doors, series, data_source
    )
    VALUES (
        p_vin, p_make, p_model, p_year, v_checksum,
        CASE WHEN v_is_valid THEN 'valid' ELSE 'invalid' END,
        COALESCE((p_specs->>'trim')::TEXT, ''),
        COALESCE((p_specs->>'body_class')::TEXT, ''),
        COALESCE((p_specs->>'engine_cylinders')::INTEGER, NULL),
        COALESCE((p_specs->>'displacement_cc')::DECIMAL, NULL),
        COALESCE((p_specs->>'fuel_type_primary')::TEXT, ''),
        COALESCE((p_specs->>'drive_type')::TEXT, ''),
        COALESCE((p_specs->>'transmission_style')::TEXT, ''),
        COALESCE((p_specs->>'manufacturer')::TEXT, ''),
        COALESCE((p_specs->>'plant_country')::TEXT, ''),
        COALESCE((p_specs->>'plant_state')::TEXT, ''),
        COALESCE((p_specs->>'vehicle_type')::TEXT, ''),
        COALESCE((p_specs->>'gvwr')::DECIMAL, NULL),
        COALESCE((p_specs->>'doors')::INTEGER, NULL),
        COALESCE((p_specs->>'series')::TEXT, ''),
        'nhtsa'
    )
    ON CONFLICT (vin) DO UPDATE SET
        make = EXCLUDED.make,
        model = EXCLUDED.model,
        year = EXCLUDED.year,
        vin_checksum = EXCLUDED.vin_checksum,
        validation_status = EXCLUDED.validation_status,
        trim = COALESCE(EXCLUDED.trim, vehicle_specs.trim),
        body_class = COALESCE(EXCLUDED.body_class, vehicle_specs.body_class),
        engine_cylinders = COALESCE(EXCLUDED.engine_cylinders, vehicle_specs.engine_cylinders),
        displacement_cc = COALESCE(EXCLUDED.displacement_cc, vehicle_specs.displacement_cc),
        fuel_type_primary = COALESCE(EXCLUDED.fuel_type_primary, vehicle_specs.fuel_type_primary),
        drive_type = COALESCE(EXCLUDED.drive_type, vehicle_specs.drive_type),
        transmission_style = COALESCE(EXCLUDED.transmission_style, vehicle_specs.transmission_style),
        manufacturer = COALESCE(EXCLUDED.manufacturer, vehicle_specs.manufacturer),
        plant_country = COALESCE(EXCLUDED.plant_country, vehicle_specs.plant_country),
        plant_state = COALESCE(EXCLUDED.plant_state, vehicle_specs.plant_state),
        vehicle_type = COALESCE(EXCLUDED.vehicle_type, vehicle_specs.vehicle_type),
        gvwr = COALESCE(EXCLUDED.gvwr, vehicle_specs.gvwr),
        doors = COALESCE(EXCLUDED.doors, vehicle_specs.doors),
        series = COALESCE(EXCLUDED.series, vehicle_specs.series),
        updated_at = NOW();
        
    RETURN QUERY SELECT 
        p_vin, 
        CASE WHEN v_is_valid THEN 'valid' ELSE 'invalid' END,
        result_created;
END;
$$;

-- Get complete vehicle profile
CREATE OR REPLACE FUNCTION rpc_get_vehicle_profile(p_vin TEXT)
RETURNS TABLE(
    vin TEXT,
    make TEXT,
    model TEXT,
    year INTEGER,
    validation_status TEXT,
    specs JSONB,
    recalls JSONB,
    safety_ratings JSONB,
    fuel_economy JSONB
)
LANGUAGE PLPGSQL
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        vs.vin,
        vs.make,
        vs.model,
        vs.year,
        vs.validation_status,
        jsonb_build_object(
            'trim', vs.trim,
            'body_class', vs.body_class,
            'engine_cylinders', vs.engine_cylinders,
            'displacement_cc', vs.displacement_cc,
            'fuel_type_primary', vs.fuel_type_primary,
            'drive_type', vs.drive_type,
            'transmission_style', vs.transmission_style,
            'manufacturer', vs.manufacturer,
            'plant_country', vs.plant_country,
            'plant_state', vs.plant_state,
            'vehicle_type', vs.vehicle_type,
            'gvwr', vs.gvwr,
            'doors', vs.doors,
            'series', vs.series,
            'data_source', vs.data_source
        ) as specs,
        COALESCE(
            (SELECT jsonb_agg(jsonb_build_object(
                'recall_id', nr.recall_id,
                'nhtsa_campaign_number', nr.nhtsa_campaign_number,
                'component', nr.component,
                'summary', nr.summary,
                'consequence', nr.consequence,
                'remedy', nr.remedy,
                'report_date', nr.report_date,
                'manufacturer', nr.manufacturer
            )) FROM nhtsa_recalls nr WHERE nr.vin = vs.vin),
            '[]'::jsonb
        ) as recalls,
        COALESCE(
            (SELECT jsonb_agg(jsonb_build_object(
                'overall_rating', nsr.overall_rating,
                'overall_front_crash_rating', nsr.overall_front_crash_rating,
                'front_crash_driver_side_rating', nsr.front_crash_driver_side_rating,
                'front_crash_passenger_side_rating', nsr.front_crash_passenger_side_rating,
                'overall_side_crash_rating', nsr.overall_side_crash_rating,
                'side_crash_driver_side_rating', nsr.side_crash_driver_side_rating,
                'side_crash_passenger_side_rating', nsr.side_crash_passenger_side_rating,
                'rollover_rating', nsr.rollover_rating,
                'dynamic_tip_result', nsr.dynamic_tip_result,
                'model_year', nsr.model_year
            )) FROM nhtsa_safety_ratings nsr WHERE nsr.vin = vs.vin),
            '[]'::jsonb
        ) as safety_ratings,
        COALESCE(
            (SELECT jsonb_agg(jsonb_build_object(
                'city_mpg', fe.city_mpg,
                'highway_mpg', fe.highway_mpg,
                'combined_mpg', fe.combined_mpg,
                'annual_fuel_cost', fe.annual_fuel_cost,
                'fuel_tank_capacity', fe.fuel_tank_capacity,
                'range_city', fe.range_city,
                'range_highway', fe.range_highway,
                'co2_emissions', fe.co2_emissions
            )) FROM fuel_economy fe WHERE fe.vin = vs.vin),
            '[]'::jsonb
        ) as fuel_economy
    FROM vehicle_specs vs
    WHERE vs.vin = p_vin;
END;
$$;

-- Cache management
CREATE OR REPLACE FUNCTION rpc_cache_get(p_key TEXT)
RETURNS TABLE(data JSONB, expired BOOLEAN)
LANGUAGE PLPGSQL
SECURITY DEFINER
AS $$
DECLARE
    cache_record api_cache%ROWTYPE;
    is_expired BOOLEAN := FALSE;
BEGIN
    SELECT * INTO cache_record FROM api_cache WHERE cache_key = p_key;
    
    IF NOT FOUND THEN
        RETURN QUERY SELECT NULL::JSONB, TRUE;
        RETURN;
    END IF;
    
    is_expired := cache_record.expires_at < NOW();
    
    IF NOT is_expired THEN
        UPDATE api_cache SET hit_count = hit_count + 1 WHERE cache_key = p_key;
    END IF;
    
    RETURN QUERY SELECT cache_record.response_data, is_expired;
END;
$$;

CREATE OR REPLACE FUNCTION rpc_cache_set(
    p_key TEXT,
    p_endpoint TEXT,
    p_params JSONB,
    p_data JSONB,
    p_ttl_hours INTEGER DEFAULT 24
)
RETURNS BOOLEAN
LANGUAGE PLPGSQL
SECURITY DEFINER
AS $$
BEGIN
    INSERT INTO api_cache (cache_key, endpoint, request_params, response_data, expires_at)
    VALUES (p_key, p_endpoint, p_params, p_data, NOW() + (p_ttl_hours || ' hours')::INTERVAL)
    ON CONFLICT (cache_key) DO UPDATE SET
        response_data = EXCLUDED.response_data,
        expires_at = EXCLUDED.expires_at,
        hit_count = 0;
    
    RETURN TRUE;
END;
$$;

-- =====================================================
-- 6. POPULATE CHECKSUM DATA
-- =====================================================

-- Update existing vehicle_specs with checksum data
UPDATE vehicle_specs 
SET 
    vin_checksum = SUBSTRING(vin FROM 9 FOR 1),
    validation_status = CASE 
        WHEN fn_validate_vin(vin) THEN 'valid' 
        ELSE 'invalid' 
    END
WHERE vin_checksum IS NULL;

-- =====================================================
-- 7. CLEANUP & OPTIMIZATION
-- =====================================================

-- Clean expired cache entries
DELETE FROM api_cache WHERE expires_at < NOW() - INTERVAL '7 days';

-- Update table statistics
ANALYZE vehicle_specs;
ANALYZE nhtsa_recalls;
ANALYZE nhtsa_safety_ratings;
ANALYZE fuel_economy;
ANALYZE api_cache;

-- Add table comments
COMMENT ON TABLE api_cache IS 'Caches external API responses with TTL and hit tracking';
COMMENT ON FUNCTION fn_validate_vin(TEXT) IS 'ISO 3779 compliant VIN validation with check digit verification';
COMMENT ON FUNCTION rpc_get_vehicle_profile(TEXT) IS 'Returns complete vehicle profile with all related data';
COMMENT ON FUNCTION rpc_upsert_vehicle_specs(TEXT,TEXT,TEXT,INTEGER,JSONB) IS 'Safely upserts vehicle specs with VIN validation';
